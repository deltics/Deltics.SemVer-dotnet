
pool:
  vmImage: 'windows-latest'

variables:
- group: lib.nuget
- name: buildConfiguration
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    value: release
  ${{ if ne(variables['Build.SourceBranch'], 'refs/heads/master') }}:
    value: debug

jobs:
- job: BuildAndTest
  steps:
    # Build
  - task: DotNetCoreCLI@2
    displayName: 'dotnet build'
    inputs:
      command: 'build'
      arguments: '--configuration $(buildConfiguration)'
      projects: '**/*.csproj'
      
    # Test
  - task: DotNetCoreCLI@2
    displayName: 'dotnet test'
    inputs:
      command: 'test'
      arguments: '--configuration $(buildConfiguration) --collect "Code coverage"'
      projects: '**/*.Tests.csproj'
      publishTestResults: true
      testRunTitle: $(Build.BuildNumber)

  # The second task is dotnet pack command again pointing to the csproj file
  # The nobuild means the project will not be compiled before running pack, because its already built in above step
- job: Packaging
  dependsOn:
  - BuildAndTest
  steps:
    # Build
  - task: DotNetCoreCLI@2
    displayName: 'dotnet build'
    inputs:
      command: 'build'
      arguments: '--configuration $(buildConfiguration)'
      projects: '**/*.csproj'

    # Package
  - task: DotNetCoreCLI@2
    displayName: "dotnet pack"
    inputs:
      command: 'pack'
      arguments: '--configuration $(buildConfiguration)'
      packagesToPack: '**/*.csproj'
      nobuild: true
      versioningScheme: 'off'

  - task: PublishPipelineArtifact@1
    displayName: Publish pipeline packages artifact
    inputs:
      targetPath: '$(Pipeline.Workspace)'
      artifactName: packages
      artifactType: pipeline   

  # Push non-master packages to the private artifact feed in Azure
  #
  # allowPackageConflicts allows us to build the same version and not throw an error when trying to push
  #  instead it just ignores the latest package unless the version changes
- job: InternalPublish
  condition: and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/master'))
  dependsOn:
  - Packaging
  steps:
  - task: DownloadPipelineArtifact@2
    displayName: Download pipeline packages artifact
    inputs:
      artifact: packages
      path: '$(Build.ArtifactStagingDirectory)'     
  - task: NuGetCommand@2
    displayName: 'push to internal/azure feed'
    inputs:
      command: 'push'
      feedsToUse: 'select'
      packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
      nuGetFeedType: 'internal'
      publishVstsFeed: 'Feed'
      versioningScheme: 'off'
      allowPackageConflicts: true

  # Publish packages from master to nuget
- job: NugetPublish
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
  dependsOn:
  - Packaging
  variables:
    apiKey: $(lib.nuget.apiKey)
  steps:
  - task: DownloadPipelineArtifact@2
    displayName: Download pipeline packages artifact
    inputs:
      artifact: packages
      path: '$(Build.ArtifactStagingDirectory)'     

  - task: DotNetCoreCLI@2
    displayName: push to nuget.org (using workaround)
    inputs:
      command: custom
      custom: nuget
      arguments: >
        push $(Build.ArtifactStagingDirectory)/**/*.nupkg
        -s https://api.nuget.org/v3/index.json
        -k $(apiKey)

# This SHOULD work for nuget, but dotnet cli doesn't support encrypted ApiKeys,
#  so for now we have to use the work-around alternative above
#
#  - task: DotNetCoreCLI@2
#    displayName: "push to nuget.org"
#    inputs:
#      command: 'push'
#      packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
#      nuGetFeedType: 'external'
#      publishFeedCredentials: 'NugetOrgApiKey'



